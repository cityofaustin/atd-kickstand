--
-- PostgreSQL database dump
--

-- Dumped from database version 12.3 (Debian 12.3-1.pgdg100+1)
-- Dumped by pg_dump version 12.3 (Debian 12.3-1.pgdg100+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: hdb_catalog; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA hdb_catalog;


ALTER SCHEMA hdb_catalog OWNER TO postgres;

--
-- Name: hdb_views; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA hdb_views;


ALTER SCHEMA hdb_views OWNER TO postgres;

--
-- Name: meta; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA meta;


ALTER SCHEMA meta OWNER TO postgres;

--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: check_violation(text); Type: FUNCTION; Schema: hdb_catalog; Owner: postgres
--

CREATE FUNCTION hdb_catalog.check_violation(msg text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
  BEGIN
    RAISE check_violation USING message=msg;
  END;
$$;


ALTER FUNCTION hdb_catalog.check_violation(msg text) OWNER TO postgres;

--
-- Name: hdb_schema_update_event_notifier(); Type: FUNCTION; Schema: hdb_catalog; Owner: postgres
--

CREATE FUNCTION hdb_catalog.hdb_schema_update_event_notifier() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  DECLARE
    instance_id uuid;
    occurred_at timestamptz;
    invalidations json;
    curr_rec record;
  BEGIN
    instance_id = NEW.instance_id;
    occurred_at = NEW.occurred_at;
    invalidations = NEW.invalidations;
    PERFORM pg_notify('hasura_schema_update', json_build_object(
      'instance_id', instance_id,
      'occurred_at', occurred_at,
      'invalidations', invalidations
      )::text);
    RETURN curr_rec;
  END;
$$;


ALTER FUNCTION hdb_catalog.hdb_schema_update_event_notifier() OWNER TO postgres;

--
-- Name: inject_table_defaults(text, text, text, text); Type: FUNCTION; Schema: hdb_catalog; Owner: postgres
--

CREATE FUNCTION hdb_catalog.inject_table_defaults(view_schema text, view_name text, tab_schema text, tab_name text) RETURNS void
    LANGUAGE plpgsql
    AS $$
    DECLARE
        r RECORD;
    BEGIN
      FOR r IN SELECT column_name, column_default FROM information_schema.columns WHERE table_schema = tab_schema AND table_name = tab_name AND column_default IS NOT NULL LOOP
          EXECUTE format('ALTER VIEW %I.%I ALTER COLUMN %I SET DEFAULT %s;', view_schema, view_name, r.column_name, r.column_default);
      END LOOP;
    END;
$$;


ALTER FUNCTION hdb_catalog.inject_table_defaults(view_schema text, view_name text, tab_schema text, tab_name text) OWNER TO postgres;

--
-- Name: insert_event_log(text, text, text, text, json); Type: FUNCTION; Schema: hdb_catalog; Owner: postgres
--

CREATE FUNCTION hdb_catalog.insert_event_log(schema_name text, table_name text, trigger_name text, op text, row_data json) RETURNS text
    LANGUAGE plpgsql
    AS $$
  DECLARE
    id text;
    payload json;
    session_variables json;
    server_version_num int;
  BEGIN
    id := gen_random_uuid();
    server_version_num := current_setting('server_version_num');
    IF server_version_num >= 90600 THEN
      session_variables := current_setting('hasura.user', 't');
    ELSE
      BEGIN
        session_variables := current_setting('hasura.user');
      EXCEPTION WHEN OTHERS THEN
                  session_variables := NULL;
      END;
    END IF;
    payload := json_build_object(
      'op', op,
      'data', row_data,
      'session_variables', session_variables
    );
    INSERT INTO hdb_catalog.event_log
                (id, schema_name, table_name, trigger_name, payload)
    VALUES
    (id, schema_name, table_name, trigger_name, payload);
    RETURN id;
  END;
$$;


ALTER FUNCTION hdb_catalog.insert_event_log(schema_name text, table_name text, trigger_name text, op text, row_data json) OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: event_invocation_logs; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.event_invocation_logs (
    id text DEFAULT public.gen_random_uuid() NOT NULL,
    event_id text,
    status integer,
    request json,
    response json,
    created_at timestamp without time zone DEFAULT now()
);


ALTER TABLE hdb_catalog.event_invocation_logs OWNER TO postgres;

--
-- Name: event_log; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.event_log (
    id text DEFAULT public.gen_random_uuid() NOT NULL,
    schema_name text NOT NULL,
    table_name text NOT NULL,
    trigger_name text NOT NULL,
    payload jsonb NOT NULL,
    delivered boolean DEFAULT false NOT NULL,
    error boolean DEFAULT false NOT NULL,
    tries integer DEFAULT 0 NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    locked boolean DEFAULT false NOT NULL,
    next_retry_at timestamp without time zone,
    archived boolean DEFAULT false NOT NULL
);


ALTER TABLE hdb_catalog.event_log OWNER TO postgres;

--
-- Name: event_triggers; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.event_triggers (
    name text NOT NULL,
    type text NOT NULL,
    schema_name text NOT NULL,
    table_name text NOT NULL,
    configuration json,
    comment text
);


ALTER TABLE hdb_catalog.event_triggers OWNER TO postgres;

--
-- Name: hdb_action; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_action (
    action_name text NOT NULL,
    action_defn jsonb NOT NULL,
    comment text,
    is_system_defined boolean DEFAULT false
);


ALTER TABLE hdb_catalog.hdb_action OWNER TO postgres;

--
-- Name: hdb_action_log; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_action_log (
    id uuid DEFAULT public.gen_random_uuid() NOT NULL,
    action_name text,
    input_payload jsonb NOT NULL,
    request_headers jsonb NOT NULL,
    session_variables jsonb NOT NULL,
    response_payload jsonb,
    errors jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    response_received_at timestamp with time zone,
    status text NOT NULL,
    CONSTRAINT hdb_action_log_status_check CHECK ((status = ANY (ARRAY['created'::text, 'processing'::text, 'completed'::text, 'error'::text])))
);


ALTER TABLE hdb_catalog.hdb_action_log OWNER TO postgres;

--
-- Name: hdb_action_permission; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_action_permission (
    action_name text NOT NULL,
    role_name text NOT NULL,
    definition jsonb DEFAULT '{}'::jsonb NOT NULL,
    comment text
);


ALTER TABLE hdb_catalog.hdb_action_permission OWNER TO postgres;

--
-- Name: hdb_allowlist; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_allowlist (
    collection_name text
);


ALTER TABLE hdb_catalog.hdb_allowlist OWNER TO postgres;

--
-- Name: hdb_check_constraint; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_check_constraint AS
 SELECT (n.nspname)::text AS table_schema,
    (ct.relname)::text AS table_name,
    (r.conname)::text AS constraint_name,
    pg_get_constraintdef(r.oid, true) AS "check"
   FROM ((pg_constraint r
     JOIN pg_class ct ON ((r.conrelid = ct.oid)))
     JOIN pg_namespace n ON ((ct.relnamespace = n.oid)))
  WHERE (r.contype = 'c'::"char");


ALTER TABLE hdb_catalog.hdb_check_constraint OWNER TO postgres;

--
-- Name: hdb_computed_field; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_computed_field (
    table_schema text NOT NULL,
    table_name text NOT NULL,
    computed_field_name text NOT NULL,
    definition jsonb NOT NULL,
    comment text
);


ALTER TABLE hdb_catalog.hdb_computed_field OWNER TO postgres;

--
-- Name: hdb_computed_field_function; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_computed_field_function AS
 SELECT hdb_computed_field.table_schema,
    hdb_computed_field.table_name,
    hdb_computed_field.computed_field_name,
        CASE
            WHEN (((hdb_computed_field.definition -> 'function'::text) ->> 'name'::text) IS NULL) THEN (hdb_computed_field.definition ->> 'function'::text)
            ELSE ((hdb_computed_field.definition -> 'function'::text) ->> 'name'::text)
        END AS function_name,
        CASE
            WHEN (((hdb_computed_field.definition -> 'function'::text) ->> 'schema'::text) IS NULL) THEN 'public'::text
            ELSE ((hdb_computed_field.definition -> 'function'::text) ->> 'schema'::text)
        END AS function_schema
   FROM hdb_catalog.hdb_computed_field;


ALTER TABLE hdb_catalog.hdb_computed_field_function OWNER TO postgres;

--
-- Name: hdb_custom_types; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_custom_types (
    custom_types jsonb NOT NULL
);


ALTER TABLE hdb_catalog.hdb_custom_types OWNER TO postgres;

--
-- Name: hdb_foreign_key_constraint; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_foreign_key_constraint AS
 SELECT (q.table_schema)::text AS table_schema,
    (q.table_name)::text AS table_name,
    (q.constraint_name)::text AS constraint_name,
    (min(q.constraint_oid))::integer AS constraint_oid,
    min((q.ref_table_table_schema)::text) AS ref_table_table_schema,
    min((q.ref_table)::text) AS ref_table,
    json_object_agg(ac.attname, afc.attname) AS column_mapping,
    min((q.confupdtype)::text) AS on_update,
    min((q.confdeltype)::text) AS on_delete,
    json_agg(ac.attname) AS columns,
    json_agg(afc.attname) AS ref_columns
   FROM ((( SELECT ctn.nspname AS table_schema,
            ct.relname AS table_name,
            r.conrelid AS table_id,
            r.conname AS constraint_name,
            r.oid AS constraint_oid,
            cftn.nspname AS ref_table_table_schema,
            cft.relname AS ref_table,
            r.confrelid AS ref_table_id,
            r.confupdtype,
            r.confdeltype,
            unnest(r.conkey) AS column_id,
            unnest(r.confkey) AS ref_column_id
           FROM ((((pg_constraint r
             JOIN pg_class ct ON ((r.conrelid = ct.oid)))
             JOIN pg_namespace ctn ON ((ct.relnamespace = ctn.oid)))
             JOIN pg_class cft ON ((r.confrelid = cft.oid)))
             JOIN pg_namespace cftn ON ((cft.relnamespace = cftn.oid)))
          WHERE (r.contype = 'f'::"char")) q
     JOIN pg_attribute ac ON (((q.column_id = ac.attnum) AND (q.table_id = ac.attrelid))))
     JOIN pg_attribute afc ON (((q.ref_column_id = afc.attnum) AND (q.ref_table_id = afc.attrelid))))
  GROUP BY q.table_schema, q.table_name, q.constraint_name;


ALTER TABLE hdb_catalog.hdb_foreign_key_constraint OWNER TO postgres;

--
-- Name: hdb_function; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_function (
    function_schema text NOT NULL,
    function_name text NOT NULL,
    configuration jsonb DEFAULT '{}'::jsonb NOT NULL,
    is_system_defined boolean DEFAULT false
);


ALTER TABLE hdb_catalog.hdb_function OWNER TO postgres;

--
-- Name: hdb_function_agg; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_function_agg AS
 SELECT (p.proname)::text AS function_name,
    (pn.nspname)::text AS function_schema,
    pd.description,
        CASE
            WHEN (p.provariadic = (0)::oid) THEN false
            ELSE true
        END AS has_variadic,
        CASE
            WHEN ((p.provolatile)::text = ('i'::character(1))::text) THEN 'IMMUTABLE'::text
            WHEN ((p.provolatile)::text = ('s'::character(1))::text) THEN 'STABLE'::text
            WHEN ((p.provolatile)::text = ('v'::character(1))::text) THEN 'VOLATILE'::text
            ELSE NULL::text
        END AS function_type,
    pg_get_functiondef(p.oid) AS function_definition,
    (rtn.nspname)::text AS return_type_schema,
    (rt.typname)::text AS return_type_name,
    (rt.typtype)::text AS return_type_type,
    p.proretset AS returns_set,
    ( SELECT COALESCE(json_agg(json_build_object('schema', q.schema, 'name', q.name, 'type', q.type)), '[]'::json) AS "coalesce"
           FROM ( SELECT pt.typname AS name,
                    pns.nspname AS schema,
                    pt.typtype AS type,
                    pat.ordinality
                   FROM ((unnest(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) WITH ORDINALITY pat(oid, ordinality)
                     LEFT JOIN pg_type pt ON ((pt.oid = pat.oid)))
                     LEFT JOIN pg_namespace pns ON ((pt.typnamespace = pns.oid)))
                  ORDER BY pat.ordinality) q) AS input_arg_types,
    to_json(COALESCE(p.proargnames, ARRAY[]::text[])) AS input_arg_names,
    p.pronargdefaults AS default_args,
    (p.oid)::integer AS function_oid
   FROM ((((pg_proc p
     JOIN pg_namespace pn ON ((pn.oid = p.pronamespace)))
     JOIN pg_type rt ON ((rt.oid = p.prorettype)))
     JOIN pg_namespace rtn ON ((rtn.oid = rt.typnamespace)))
     LEFT JOIN pg_description pd ON ((p.oid = pd.objoid)))
  WHERE (((pn.nspname)::text !~~ 'pg_%'::text) AND ((pn.nspname)::text <> ALL (ARRAY['information_schema'::text, 'hdb_catalog'::text, 'hdb_views'::text])) AND (NOT (EXISTS ( SELECT 1
           FROM pg_aggregate
          WHERE ((pg_aggregate.aggfnoid)::oid = p.oid)))));


ALTER TABLE hdb_catalog.hdb_function_agg OWNER TO postgres;

--
-- Name: hdb_function_info_agg; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_function_info_agg AS
 SELECT hdb_function_agg.function_name,
    hdb_function_agg.function_schema,
    row_to_json(( SELECT e.*::record AS e
           FROM ( SELECT hdb_function_agg.description,
                    hdb_function_agg.has_variadic,
                    hdb_function_agg.function_type,
                    hdb_function_agg.return_type_schema,
                    hdb_function_agg.return_type_name,
                    hdb_function_agg.return_type_type,
                    hdb_function_agg.returns_set,
                    hdb_function_agg.input_arg_types,
                    hdb_function_agg.input_arg_names,
                    hdb_function_agg.default_args,
                    (EXISTS ( SELECT 1
                           FROM information_schema.tables
                          WHERE (((tables.table_schema)::name = hdb_function_agg.return_type_schema) AND ((tables.table_name)::name = hdb_function_agg.return_type_name)))) AS returns_table) e)) AS function_info
   FROM hdb_catalog.hdb_function_agg;


ALTER TABLE hdb_catalog.hdb_function_info_agg OWNER TO postgres;

--
-- Name: hdb_permission; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_permission (
    table_schema name NOT NULL,
    table_name name NOT NULL,
    role_name text NOT NULL,
    perm_type text NOT NULL,
    perm_def jsonb NOT NULL,
    comment text,
    is_system_defined boolean DEFAULT false,
    CONSTRAINT hdb_permission_perm_type_check CHECK ((perm_type = ANY (ARRAY['insert'::text, 'select'::text, 'update'::text, 'delete'::text])))
);


ALTER TABLE hdb_catalog.hdb_permission OWNER TO postgres;

--
-- Name: hdb_permission_agg; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_permission_agg AS
 SELECT hdb_permission.table_schema,
    hdb_permission.table_name,
    hdb_permission.role_name,
    json_object_agg(hdb_permission.perm_type, hdb_permission.perm_def) AS permissions
   FROM hdb_catalog.hdb_permission
  GROUP BY hdb_permission.table_schema, hdb_permission.table_name, hdb_permission.role_name;


ALTER TABLE hdb_catalog.hdb_permission_agg OWNER TO postgres;

--
-- Name: hdb_primary_key; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_primary_key AS
 SELECT tc.table_schema,
    tc.table_name,
    tc.constraint_name,
    json_agg(constraint_column_usage.column_name) AS columns
   FROM (information_schema.table_constraints tc
     JOIN ( SELECT x.tblschema AS table_schema,
            x.tblname AS table_name,
            x.colname AS column_name,
            x.cstrname AS constraint_name
           FROM ( SELECT DISTINCT nr.nspname,
                    r.relname,
                    a.attname,
                    c.conname
                   FROM pg_namespace nr,
                    pg_class r,
                    pg_attribute a,
                    pg_depend d,
                    pg_namespace nc,
                    pg_constraint c
                  WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (d.refobjid = r.oid) AND (d.refobjsubid = a.attnum) AND (d.classid = ('pg_constraint'::regclass)::oid) AND (d.objid = c.oid) AND (c.connamespace = nc.oid) AND (c.contype = 'c'::"char") AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT a.attisdropped))
                UNION ALL
                 SELECT nr.nspname,
                    r.relname,
                    a.attname,
                    c.conname
                   FROM pg_namespace nr,
                    pg_class r,
                    pg_attribute a,
                    pg_namespace nc,
                    pg_constraint c
                  WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (nc.oid = c.connamespace) AND (r.oid =
                        CASE c.contype
                            WHEN 'f'::"char" THEN c.confrelid
                            ELSE c.conrelid
                        END) AND (a.attnum = ANY (
                        CASE c.contype
                            WHEN 'f'::"char" THEN c.confkey
                            ELSE c.conkey
                        END)) AND (NOT a.attisdropped) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])))) x(tblschema, tblname, colname, cstrname)) constraint_column_usage ON ((((tc.constraint_name)::text = (constraint_column_usage.constraint_name)::text) AND ((tc.table_schema)::text = (constraint_column_usage.table_schema)::text) AND ((tc.table_name)::text = (constraint_column_usage.table_name)::text))))
  WHERE ((tc.constraint_type)::text = 'PRIMARY KEY'::text)
  GROUP BY tc.table_schema, tc.table_name, tc.constraint_name;


ALTER TABLE hdb_catalog.hdb_primary_key OWNER TO postgres;

--
-- Name: hdb_query_collection; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_query_collection (
    collection_name text NOT NULL,
    collection_defn jsonb NOT NULL,
    comment text,
    is_system_defined boolean DEFAULT false
);


ALTER TABLE hdb_catalog.hdb_query_collection OWNER TO postgres;

--
-- Name: hdb_relationship; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_relationship (
    table_schema name NOT NULL,
    table_name name NOT NULL,
    rel_name text NOT NULL,
    rel_type text,
    rel_def jsonb NOT NULL,
    comment text,
    is_system_defined boolean DEFAULT false,
    CONSTRAINT hdb_relationship_rel_type_check CHECK ((rel_type = ANY (ARRAY['object'::text, 'array'::text])))
);


ALTER TABLE hdb_catalog.hdb_relationship OWNER TO postgres;

--
-- Name: hdb_role; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_role AS
 SELECT DISTINCT q.role_name
   FROM ( SELECT hdb_permission.role_name
           FROM hdb_catalog.hdb_permission
        UNION ALL
         SELECT hdb_action_permission.role_name
           FROM hdb_catalog.hdb_action_permission) q;


ALTER TABLE hdb_catalog.hdb_role OWNER TO postgres;

--
-- Name: hdb_schema_update_event; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_schema_update_event (
    instance_id uuid NOT NULL,
    occurred_at timestamp with time zone DEFAULT now() NOT NULL,
    invalidations json NOT NULL
);


ALTER TABLE hdb_catalog.hdb_schema_update_event OWNER TO postgres;

--
-- Name: hdb_table; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_table (
    table_schema name NOT NULL,
    table_name name NOT NULL,
    configuration jsonb,
    is_system_defined boolean DEFAULT false,
    is_enum boolean DEFAULT false NOT NULL
);


ALTER TABLE hdb_catalog.hdb_table OWNER TO postgres;

--
-- Name: hdb_table_info_agg; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_table_info_agg AS
 SELECT schema.nspname AS table_schema,
    "table".relname AS table_name,
    jsonb_build_object('oid', ("table".oid)::integer, 'columns', COALESCE(columns.info, '[]'::jsonb), 'primary_key', primary_key.info, 'unique_constraints', COALESCE(unique_constraints.info, '[]'::jsonb), 'foreign_keys', COALESCE(foreign_key_constraints.info, '[]'::jsonb), 'view_info',
        CASE "table".relkind
            WHEN 'v'::"char" THEN jsonb_build_object('is_updatable', ((pg_relation_is_updatable(("table".oid)::regclass, true) & 4) = 4), 'is_insertable', ((pg_relation_is_updatable(("table".oid)::regclass, true) & 8) = 8), 'is_deletable', ((pg_relation_is_updatable(("table".oid)::regclass, true) & 16) = 16))
            ELSE NULL::jsonb
        END, 'description', description.description) AS info
   FROM ((((((pg_class "table"
     JOIN pg_namespace schema ON ((schema.oid = "table".relnamespace)))
     LEFT JOIN pg_description description ON (((description.classoid = ('pg_class'::regclass)::oid) AND (description.objoid = "table".oid) AND (description.objsubid = 0))))
     LEFT JOIN LATERAL ( SELECT jsonb_agg(jsonb_build_object('name', "column".attname, 'position', "column".attnum, 'type', COALESCE(base_type.typname, type.typname), 'is_nullable', (NOT "column".attnotnull), 'description', col_description("table".oid, ("column".attnum)::integer))) AS info
           FROM ((pg_attribute "column"
             LEFT JOIN pg_type type ON ((type.oid = "column".atttypid)))
             LEFT JOIN pg_type base_type ON (((type.typtype = 'd'::"char") AND (base_type.oid = type.typbasetype))))
          WHERE (("column".attrelid = "table".oid) AND ("column".attnum > 0) AND (NOT "column".attisdropped))) columns ON (true))
     LEFT JOIN LATERAL ( SELECT jsonb_build_object('constraint', jsonb_build_object('name', class.relname, 'oid', (class.oid)::integer), 'columns', COALESCE(columns_1.info, '[]'::jsonb)) AS info
           FROM ((pg_index index
             JOIN pg_class class ON ((class.oid = index.indexrelid)))
             LEFT JOIN LATERAL ( SELECT jsonb_agg("column".attname) AS info
                   FROM pg_attribute "column"
                  WHERE (("column".attrelid = "table".oid) AND ("column".attnum = ANY ((index.indkey)::smallint[])))) columns_1 ON (true))
          WHERE ((index.indrelid = "table".oid) AND index.indisprimary)) primary_key ON (true))
     LEFT JOIN LATERAL ( SELECT jsonb_agg(jsonb_build_object('name', class.relname, 'oid', (class.oid)::integer)) AS info
           FROM (pg_index index
             JOIN pg_class class ON ((class.oid = index.indexrelid)))
          WHERE ((index.indrelid = "table".oid) AND index.indisunique AND (NOT index.indisprimary))) unique_constraints ON (true))
     LEFT JOIN LATERAL ( SELECT jsonb_agg(jsonb_build_object('constraint', jsonb_build_object('name', foreign_key.constraint_name, 'oid', foreign_key.constraint_oid), 'columns', foreign_key.columns, 'foreign_table', jsonb_build_object('schema', foreign_key.ref_table_table_schema, 'name', foreign_key.ref_table), 'foreign_columns', foreign_key.ref_columns)) AS info
           FROM hdb_catalog.hdb_foreign_key_constraint foreign_key
          WHERE ((foreign_key.table_schema = schema.nspname) AND (foreign_key.table_name = "table".relname))) foreign_key_constraints ON (true))
  WHERE ("table".relkind = ANY (ARRAY['r'::"char", 't'::"char", 'v'::"char", 'm'::"char", 'f'::"char", 'p'::"char"]));


ALTER TABLE hdb_catalog.hdb_table_info_agg OWNER TO postgres;

--
-- Name: hdb_unique_constraint; Type: VIEW; Schema: hdb_catalog; Owner: postgres
--

CREATE VIEW hdb_catalog.hdb_unique_constraint AS
 SELECT tc.table_name,
    tc.constraint_schema AS table_schema,
    tc.constraint_name,
    json_agg(kcu.column_name) AS columns
   FROM (information_schema.table_constraints tc
     JOIN information_schema.key_column_usage kcu USING (constraint_schema, constraint_name))
  WHERE ((tc.constraint_type)::text = 'UNIQUE'::text)
  GROUP BY tc.table_name, tc.constraint_schema, tc.constraint_name;


ALTER TABLE hdb_catalog.hdb_unique_constraint OWNER TO postgres;

--
-- Name: hdb_version; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.hdb_version (
    hasura_uuid uuid DEFAULT public.gen_random_uuid() NOT NULL,
    version text NOT NULL,
    upgraded_on timestamp with time zone NOT NULL,
    cli_state jsonb DEFAULT '{}'::jsonb NOT NULL,
    console_state jsonb DEFAULT '{}'::jsonb NOT NULL
);


ALTER TABLE hdb_catalog.hdb_version OWNER TO postgres;

--
-- Name: remote_schemas; Type: TABLE; Schema: hdb_catalog; Owner: postgres
--

CREATE TABLE hdb_catalog.remote_schemas (
    id bigint NOT NULL,
    name text,
    definition json,
    comment text
);


ALTER TABLE hdb_catalog.remote_schemas OWNER TO postgres;

--
-- Name: remote_schemas_id_seq; Type: SEQUENCE; Schema: hdb_catalog; Owner: postgres
--

CREATE SEQUENCE hdb_catalog.remote_schemas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hdb_catalog.remote_schemas_id_seq OWNER TO postgres;

--
-- Name: remote_schemas_id_seq; Type: SEQUENCE OWNED BY; Schema: hdb_catalog; Owner: postgres
--

ALTER SEQUENCE hdb_catalog.remote_schemas_id_seq OWNED BY hdb_catalog.remote_schemas.id;


--
-- Name: fields; Type: TABLE; Schema: meta; Owner: postgres
--

CREATE TABLE meta.fields (
    id integer NOT NULL,
    name text,
    label text,
    data_type text,
    input_type text,
    options text[],
    table_name text NOT NULL,
    subfields text,
    helper_text text,
    placeholder text
);


ALTER TABLE meta.fields OWNER TO postgres;

--
-- Name: fields_id_seq; Type: SEQUENCE; Schema: meta; Owner: postgres
--

CREATE SEQUENCE meta.fields_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE meta.fields_id_seq OWNER TO postgres;

--
-- Name: fields_id_seq; Type: SEQUENCE OWNED BY; Schema: meta; Owner: postgres
--

ALTER SEQUENCE meta.fields_id_seq OWNED BY meta.fields.id;


--
-- Name: forms; Type: TABLE; Schema: meta; Owner: postgres
--

CREATE TABLE meta.forms (
    id integer NOT NULL,
    view_id integer,
    description text,
    action text DEFAULT 'insert'::text NOT NULL,
    mutation text
);


ALTER TABLE meta.forms OWNER TO postgres;

--
-- Name: forms_id_seq; Type: SEQUENCE; Schema: meta; Owner: postgres
--

CREATE SEQUENCE meta.forms_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE meta.forms_id_seq OWNER TO postgres;

--
-- Name: forms_id_seq; Type: SEQUENCE OWNED BY; Schema: meta; Owner: postgres
--

ALTER SEQUENCE meta.forms_id_seq OWNED BY meta.forms.id;


--
-- Name: many_forms_to_many_fields; Type: TABLE; Schema: meta; Owner: postgres
--

CREATE TABLE meta.many_forms_to_many_fields (
    form_id integer NOT NULL,
    field_id integer NOT NULL,
    read_only boolean DEFAULT false NOT NULL,
    "row" integer DEFAULT 1,
    weight integer DEFAULT 1 NOT NULL
);


ALTER TABLE meta.many_forms_to_many_fields OWNER TO postgres;

--
-- Name: forms_with_fields; Type: VIEW; Schema: meta; Owner: postgres
--

CREATE VIEW meta.forms_with_fields AS
 SELECT fields.id,
    fields.label,
    fields.data_type,
    fields.input_type,
    fields.options,
    fields.table_name,
    fields.subfields,
    fields.helper_text,
    fields.placeholder,
    forms.id AS form_id,
    forms.view_id
   FROM ((meta.fields
     JOIN meta.many_forms_to_many_fields ON ((many_forms_to_many_fields.field_id = fields.id)))
     JOIN meta.forms ON ((many_forms_to_many_fields.form_id = forms.id)));


ALTER TABLE meta.forms_with_fields OWNER TO postgres;

--
-- Name: many_tables_to_many_fields; Type: TABLE; Schema: meta; Owner: postgres
--

CREATE TABLE meta.many_tables_to_many_fields (
    table_id integer NOT NULL,
    field_id integer NOT NULL,
    read_only boolean DEFAULT false NOT NULL,
    weight integer DEFAULT 1 NOT NULL
);


ALTER TABLE meta.many_tables_to_many_fields OWNER TO postgres;

--
-- Name: menus; Type: TABLE; Schema: meta; Owner: postgres
--

CREATE TABLE meta.menus (
    id integer NOT NULL,
    buttons jsonb NOT NULL,
    label text NOT NULL,
    description text NOT NULL,
    view_id integer
);


ALTER TABLE meta.menus OWNER TO postgres;

--
-- Name: menus_id_seq; Type: SEQUENCE; Schema: meta; Owner: postgres
--

CREATE SEQUENCE meta.menus_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE meta.menus_id_seq OWNER TO postgres;

--
-- Name: menus_id_seq; Type: SEQUENCE OWNED BY; Schema: meta; Owner: postgres
--

ALTER SEQUENCE meta.menus_id_seq OWNED BY meta.menus.id;


--
-- Name: pages; Type: TABLE; Schema: meta; Owner: postgres
--

CREATE TABLE meta.pages (
    id integer NOT NULL,
    route text NOT NULL,
    label text NOT NULL,
    description text NOT NULL,
    use_param text DEFAULT false,
    query_id integer,
    slug text NOT NULL,
    show_in_menu boolean DEFAULT true NOT NULL,
    weight integer DEFAULT 1 NOT NULL
);


ALTER TABLE meta.pages OWNER TO postgres;

--
-- Name: pages_id_seq; Type: SEQUENCE; Schema: meta; Owner: postgres
--

CREATE SEQUENCE meta.pages_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE meta.pages_id_seq OWNER TO postgres;

--
-- Name: pages_id_seq; Type: SEQUENCE OWNED BY; Schema: meta; Owner: postgres
--

ALTER SEQUENCE meta.pages_id_seq OWNED BY meta.pages.id;


--
-- Name: queries; Type: TABLE; Schema: meta; Owner: postgres
--

CREATE TABLE meta.queries (
    id integer NOT NULL,
    gql text,
    description text NOT NULL
);


ALTER TABLE meta.queries OWNER TO postgres;

--
-- Name: queries_id_seq; Type: SEQUENCE; Schema: meta; Owner: postgres
--

CREATE SEQUENCE meta.queries_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE meta.queries_id_seq OWNER TO postgres;

--
-- Name: queries_id_seq; Type: SEQUENCE OWNED BY; Schema: meta; Owner: postgres
--

ALTER SEQUENCE meta.queries_id_seq OWNED BY meta.queries.id;


--
-- Name: tables; Type: TABLE; Schema: meta; Owner: postgres
--

CREATE TABLE meta.tables (
    id integer NOT NULL,
    view_id integer NOT NULL,
    links jsonb,
    query_id integer,
    description text
);


ALTER TABLE meta.tables OWNER TO postgres;

--
-- Name: tables_id_seq; Type: SEQUENCE; Schema: meta; Owner: postgres
--

CREATE SEQUENCE meta.tables_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE meta.tables_id_seq OWNER TO postgres;

--
-- Name: tables_id_seq; Type: SEQUENCE OWNED BY; Schema: meta; Owner: postgres
--

ALTER SEQUENCE meta.tables_id_seq OWNED BY meta.tables.id;


--
-- Name: tables_with_fields; Type: VIEW; Schema: meta; Owner: postgres
--

CREATE VIEW meta.tables_with_fields AS
 SELECT fields.id,
    fields.label,
    fields.data_type,
    fields.input_type,
    fields.options,
    fields.table_name,
    fields.subfields,
    fields.helper_text,
    fields.placeholder,
    tables.id AS table_id,
    tables.view_id
   FROM ((meta.fields
     JOIN meta.many_tables_to_many_fields ON ((many_tables_to_many_fields.field_id = fields.id)))
     JOIN meta.tables ON ((many_tables_to_many_fields.table_id = tables.id)));


ALTER TABLE meta.tables_with_fields OWNER TO postgres;

--
-- Name: views; Type: TABLE; Schema: meta; Owner: postgres
--

CREATE TABLE meta.views (
    id integer NOT NULL,
    page_id integer,
    label text NOT NULL,
    type text NOT NULL,
    weight integer DEFAULT 0
);


ALTER TABLE meta.views OWNER TO postgres;

--
-- Name: views_id_seq; Type: SEQUENCE; Schema: meta; Owner: postgres
--

CREATE SEQUENCE meta.views_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE meta.views_id_seq OWNER TO postgres;

--
-- Name: views_id_seq; Type: SEQUENCE OWNED BY; Schema: meta; Owner: postgres
--

ALTER SEQUENCE meta.views_id_seq OWNED BY meta.views.id;


--
-- Name: views_with_pages_forms; Type: VIEW; Schema: meta; Owner: postgres
--

CREATE VIEW meta.views_with_pages_forms AS
 SELECT views.id,
    views.page_id,
    views.label,
    views.type,
    pages.slug,
    pages.route AS page_route,
    pages.label AS page_label,
    pages.description AS page_description,
    pages.use_param AS page_user_param,
    pages.query_id AS page_query_id
   FROM (meta.views
     LEFT JOIN meta.pages ON ((views.page_id = pages.id)))
  WHERE (views.type = 'form'::text);


ALTER TABLE meta.views_with_pages_forms OWNER TO postgres;

--
-- Name: views_with_pages_tables; Type: VIEW; Schema: meta; Owner: postgres
--

CREATE VIEW meta.views_with_pages_tables AS
 SELECT views.id,
    views.page_id,
    views.label,
    views.type,
    pages.slug,
    pages.route AS page_route,
    pages.label AS page_label,
    pages.description AS page_description,
    pages.use_param AS page_user_param,
    pages.query_id AS page_query_id
   FROM (meta.views
     LEFT JOIN meta.pages ON ((views.page_id = pages.id)))
  WHERE (views.type = 'table'::text);


ALTER TABLE meta.views_with_pages_tables OWNER TO postgres;

--
-- Name: locations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.locations (
    id integer NOT NULL,
    landmark text,
    council_district text[],
    modified_date timestamp with time zone,
    location_name text,
    knack_id text
);


ALTER TABLE public.locations OWNER TO postgres;

--
-- Name: locations_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.locations_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.locations_id_seq OWNER TO postgres;

--
-- Name: locations_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.locations_id_seq OWNED BY public.locations.id;


--
-- Name: tmc_activities; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tmc_activities (
    id integer NOT NULL,
    tmc_activity text NOT NULL,
    tmc_activity_datetime timestamp with time zone,
    tmc_issue_id integer
);


ALTER TABLE public.tmc_activities OWNER TO postgres;

--
-- Name: tmc_activities_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.tmc_activities_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tmc_activities_id_seq OWNER TO postgres;

--
-- Name: tmc_activities_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.tmc_activities_id_seq OWNED BY public.tmc_activities.id;


--
-- Name: tmc_issues; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tmc_issues (
    id integer NOT NULL,
    issue_description text NOT NULL,
    location_id integer
);


ALTER TABLE public.tmc_issues OWNER TO postgres;

--
-- Name: tmc_issues_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.tmc_issues_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tmc_issues_id_seq OWNER TO postgres;

--
-- Name: tmc_issues_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.tmc_issues_id_seq OWNED BY public.tmc_issues.id;


--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    email_address text NOT NULL,
    name jsonb NOT NULL,
    id integer NOT NULL,
    status text DEFAULT 'active'::text NOT NULL
);


ALTER TABLE public.users OWNER TO postgres;

--
-- Name: users_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.users_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.users_id_seq OWNER TO postgres;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.users_id_seq OWNED BY public.users.id;


--
-- Name: remote_schemas id; Type: DEFAULT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.remote_schemas ALTER COLUMN id SET DEFAULT nextval('hdb_catalog.remote_schemas_id_seq'::regclass);


--
-- Name: fields id; Type: DEFAULT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.fields ALTER COLUMN id SET DEFAULT nextval('meta.fields_id_seq'::regclass);


--
-- Name: forms id; Type: DEFAULT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.forms ALTER COLUMN id SET DEFAULT nextval('meta.forms_id_seq'::regclass);


--
-- Name: menus id; Type: DEFAULT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.menus ALTER COLUMN id SET DEFAULT nextval('meta.menus_id_seq'::regclass);


--
-- Name: pages id; Type: DEFAULT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.pages ALTER COLUMN id SET DEFAULT nextval('meta.pages_id_seq'::regclass);


--
-- Name: queries id; Type: DEFAULT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.queries ALTER COLUMN id SET DEFAULT nextval('meta.queries_id_seq'::regclass);


--
-- Name: tables id; Type: DEFAULT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.tables ALTER COLUMN id SET DEFAULT nextval('meta.tables_id_seq'::regclass);


--
-- Name: views id; Type: DEFAULT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.views ALTER COLUMN id SET DEFAULT nextval('meta.views_id_seq'::regclass);


--
-- Name: locations id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.locations ALTER COLUMN id SET DEFAULT nextval('public.locations_id_seq'::regclass);


--
-- Name: tmc_activities id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tmc_activities ALTER COLUMN id SET DEFAULT nextval('public.tmc_activities_id_seq'::regclass);


--
-- Name: tmc_issues id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tmc_issues ALTER COLUMN id SET DEFAULT nextval('public.tmc_issues_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users ALTER COLUMN id SET DEFAULT nextval('public.users_id_seq'::regclass);


--
-- Data for Name: event_invocation_logs; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.event_invocation_logs (id, event_id, status, request, response, created_at) FROM stdin;
\.


--
-- Data for Name: event_log; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.event_log (id, schema_name, table_name, trigger_name, payload, delivered, error, tries, created_at, locked, next_retry_at, archived) FROM stdin;
\.


--
-- Data for Name: event_triggers; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.event_triggers (name, type, schema_name, table_name, configuration, comment) FROM stdin;
\.


--
-- Data for Name: hdb_action; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_action (action_name, action_defn, comment, is_system_defined) FROM stdin;
\.


--
-- Data for Name: hdb_action_log; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_action_log (id, action_name, input_payload, request_headers, session_variables, response_payload, errors, created_at, response_received_at, status) FROM stdin;
\.


--
-- Data for Name: hdb_action_permission; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_action_permission (action_name, role_name, definition, comment) FROM stdin;
\.


--
-- Data for Name: hdb_allowlist; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_allowlist (collection_name) FROM stdin;
\.


--
-- Data for Name: hdb_computed_field; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_computed_field (table_schema, table_name, computed_field_name, definition, comment) FROM stdin;
\.


--
-- Data for Name: hdb_custom_types; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_custom_types (custom_types) FROM stdin;
\.


--
-- Data for Name: hdb_function; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_function (function_schema, function_name, configuration, is_system_defined) FROM stdin;
\.


--
-- Data for Name: hdb_permission; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_permission (table_schema, table_name, role_name, perm_type, perm_def, comment, is_system_defined) FROM stdin;
\.


--
-- Data for Name: hdb_query_collection; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_query_collection (collection_name, collection_defn, comment, is_system_defined) FROM stdin;
\.


--
-- Data for Name: hdb_relationship; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_relationship (table_schema, table_name, rel_name, rel_type, rel_def, comment, is_system_defined) FROM stdin;
hdb_catalog	hdb_table	detail	object	{"manual_configuration": {"remote_table": {"name": "tables", "schema": "information_schema"}, "column_mapping": {"table_name": "table_name", "table_schema": "table_schema"}}}	\N	t
hdb_catalog	hdb_table	primary_key	object	{"manual_configuration": {"remote_table": {"name": "hdb_primary_key", "schema": "hdb_catalog"}, "column_mapping": {"table_name": "table_name", "table_schema": "table_schema"}}}	\N	t
hdb_catalog	hdb_table	columns	array	{"manual_configuration": {"remote_table": {"name": "columns", "schema": "information_schema"}, "column_mapping": {"table_name": "table_name", "table_schema": "table_schema"}}}	\N	t
hdb_catalog	hdb_table	foreign_key_constraints	array	{"manual_configuration": {"remote_table": {"name": "hdb_foreign_key_constraint", "schema": "hdb_catalog"}, "column_mapping": {"table_name": "table_name", "table_schema": "table_schema"}}}	\N	t
hdb_catalog	hdb_table	relationships	array	{"manual_configuration": {"remote_table": {"name": "hdb_relationship", "schema": "hdb_catalog"}, "column_mapping": {"table_name": "table_name", "table_schema": "table_schema"}}}	\N	t
hdb_catalog	hdb_table	permissions	array	{"manual_configuration": {"remote_table": {"name": "hdb_permission_agg", "schema": "hdb_catalog"}, "column_mapping": {"table_name": "table_name", "table_schema": "table_schema"}}}	\N	t
hdb_catalog	hdb_table	computed_fields	array	{"manual_configuration": {"remote_table": {"name": "hdb_computed_field", "schema": "hdb_catalog"}, "column_mapping": {"table_name": "table_name", "table_schema": "table_schema"}}}	\N	t
hdb_catalog	hdb_table	check_constraints	array	{"manual_configuration": {"remote_table": {"name": "hdb_check_constraint", "schema": "hdb_catalog"}, "column_mapping": {"table_name": "table_name", "table_schema": "table_schema"}}}	\N	t
hdb_catalog	hdb_table	unique_constraints	array	{"manual_configuration": {"remote_table": {"name": "hdb_unique_constraint", "schema": "hdb_catalog"}, "column_mapping": {"table_name": "table_name", "table_schema": "table_schema"}}}	\N	t
hdb_catalog	event_triggers	events	array	{"manual_configuration": {"remote_table": {"name": "event_log", "schema": "hdb_catalog"}, "column_mapping": {"name": "trigger_name"}}}	\N	t
hdb_catalog	event_log	trigger	object	{"manual_configuration": {"remote_table": {"name": "event_triggers", "schema": "hdb_catalog"}, "column_mapping": {"trigger_name": "name"}}}	\N	t
hdb_catalog	event_log	logs	array	{"foreign_key_constraint_on": {"table": {"name": "event_invocation_logs", "schema": "hdb_catalog"}, "column": "event_id"}}	\N	t
hdb_catalog	event_invocation_logs	event	object	{"foreign_key_constraint_on": "event_id"}	\N	t
hdb_catalog	hdb_function_agg	return_table_info	object	{"manual_configuration": {"remote_table": {"name": "hdb_table", "schema": "hdb_catalog"}, "column_mapping": {"return_type_name": "table_name", "return_type_schema": "table_schema"}}}	\N	t
hdb_catalog	hdb_action	permissions	array	{"manual_configuration": {"remote_table": {"name": "hdb_action_permission", "schema": "hdb_catalog"}, "column_mapping": {"action_name": "action_name"}}}	\N	t
hdb_catalog	hdb_role	action_permissions	array	{"manual_configuration": {"remote_table": {"name": "hdb_action_permission", "schema": "hdb_catalog"}, "column_mapping": {"role_name": "role_name"}}}	\N	t
hdb_catalog	hdb_role	permissions	array	{"manual_configuration": {"remote_table": {"name": "hdb_permission_agg", "schema": "hdb_catalog"}, "column_mapping": {"role_name": "role_name"}}}	\N	t
meta	pages	views	array	{"foreign_key_constraint_on": {"table": {"name": "views", "schema": "meta"}, "column": "page_id"}}	\N	f
meta	views	page	object	{"foreign_key_constraint_on": "page_id"}	\N	f
meta	many_forms_to_many_fields	field	object	{"foreign_key_constraint_on": "field_id"}	\N	f
meta	many_forms_to_many_fields	form	object	{"foreign_key_constraint_on": "form_id"}	\N	f
meta	forms	view	object	{"foreign_key_constraint_on": "view_id"}	\N	f
meta	forms	fields	array	{"foreign_key_constraint_on": {"table": {"name": "many_forms_to_many_fields", "schema": "meta"}, "column": "form_id"}}	\N	f
meta	fields	forms	array	{"foreign_key_constraint_on": {"table": {"name": "many_forms_to_many_fields", "schema": "meta"}, "column": "field_id"}}	\N	f
meta	views	forms	array	{"foreign_key_constraint_on": {"table": {"name": "forms", "schema": "meta"}, "column": "view_id"}}	\N	f
meta	tables	view	object	{"foreign_key_constraint_on": "view_id"}	\N	f
meta	pages	query	object	{"foreign_key_constraint_on": "query_id"}	\N	f
meta	queries	pages	array	{"foreign_key_constraint_on": {"table": {"name": "pages", "schema": "meta"}, "column": "query_id"}}	\N	f
meta	many_tables_to_many_fields	field	object	{"foreign_key_constraint_on": "field_id"}	\N	f
meta	many_tables_to_many_fields	table	object	{"foreign_key_constraint_on": "table_id"}	\N	f
meta	views	tables	array	{"foreign_key_constraint_on": {"table": {"name": "tables", "schema": "meta"}, "column": "view_id"}}	\N	f
meta	fields	many_tables_to_many_fields	array	{"foreign_key_constraint_on": {"table": {"name": "many_tables_to_many_fields", "schema": "meta"}, "column": "field_id"}}	\N	f
meta	tables	fields	array	{"foreign_key_constraint_on": {"table": {"name": "many_tables_to_many_fields", "schema": "meta"}, "column": "table_id"}}	\N	f
meta	tables	query	object	{"foreign_key_constraint_on": "query_id"}	\N	f
meta	queries	tables	array	{"foreign_key_constraint_on": {"table": {"name": "tables", "schema": "meta"}, "column": "query_id"}}	\N	f
meta	menus	view	object	{"foreign_key_constraint_on": "view_id"}	\N	f
meta	views	menus	array	{"foreign_key_constraint_on": {"table": {"name": "menus", "schema": "meta"}, "column": "view_id"}}	\N	f
\.


--
-- Data for Name: hdb_schema_update_event; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_schema_update_event (instance_id, occurred_at, invalidations) FROM stdin;
cd9f5db0-d1a2-435c-b508-1b04907eb1d2	2020-07-29 02:35:50.654261+00	{"metadata":false,"remote_schemas":[]}
\.


--
-- Data for Name: hdb_table; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_table (table_schema, table_name, configuration, is_system_defined, is_enum) FROM stdin;
information_schema	tables	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
information_schema	schemata	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
information_schema	views	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
information_schema	columns	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_table	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_primary_key	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_foreign_key_constraint	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_relationship	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_permission_agg	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_computed_field	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_check_constraint	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_unique_constraint	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	event_triggers	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	event_log	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	event_invocation_logs	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_function	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_function_agg	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	remote_schemas	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_version	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_query_collection	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_allowlist	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_custom_types	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_action_permission	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_action	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_action_log	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
hdb_catalog	hdb_role	{"custom_root_fields": {}, "custom_column_names": {}}	t	f
public	locations	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
public	tmc_issues	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
public	tmc_activities	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	pages	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	views	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	fields	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
public	users	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	forms	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	many_forms_to_many_fields	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	tables	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	many_tables_to_many_fields	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	queries	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	tables_with_fields	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	views_with_pages_tables	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	views_with_pages_forms	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	forms_with_fields	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
meta	menus	{"custom_root_fields": {}, "custom_column_names": {}}	f	f
\.


--
-- Data for Name: hdb_version; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.hdb_version (hasura_uuid, version, upgraded_on, cli_state, console_state) FROM stdin;
7a197ca4-4dfb-4834-924b-d7512e77223d	34	2020-07-26 03:03:46.860611+00	{}	{"telemetryNotificationShown": true}
\.


--
-- Data for Name: remote_schemas; Type: TABLE DATA; Schema: hdb_catalog; Owner: postgres
--

COPY hdb_catalog.remote_schemas (id, name, definition, comment) FROM stdin;
\.


--
-- Data for Name: fields; Type: TABLE DATA; Schema: meta; Owner: postgres
--

COPY meta.fields (id, name, label, data_type, input_type, options, table_name, subfields, helper_text, placeholder) FROM stdin;
1	email_address	Email Address	text	email	\N	users	\N	You have one; we need it.	Your email address...
3	status	 Status	text[]	select	{'active','inactive','pending'}	users	\N	\N	\N
4	slug	Slug	text	text	\N	meta.pages	\N	Must be a unique route name in your app	
5	label	Label	text	text	\N	meta.pages		The human-friendly label for this page	\N
7	description	Description	text	text	\N	meta.pages	\N	\N	\N
9	label	Label	text	text	\N	meta.views	\N	The view's label	\N
10	type	Type	text	text	\N	meta.views	\N	The type of view	\N
11	route	Route	txt	text	\N	meta.pages	\N	The route to this page in the app	\N
13	name	Name	text	text	\N	meta.fields	\N	The field's database name	\N
14	label	Label	text	text	\N	meta.fields	\N	The field's humanized label	\N
15	data_type	Data Type	text	text	\N	meta.fields	\N	The field's database date type store	\N
16	input_type	Input Type	text	text	\N	meta.fields	\N	The type of form control input to use for this field.	\N
17	options	Options	text[]	text	\N	meta.fields	\N	An array of options supported for this field. Used to populate drop-down menus	\N
18	table_name	Table name	text	text	\N	meta.fields	\N	The field's host table name in the database	\N
19	helper_text	Helper Text	text	text	\N	meta.fields	\N	The helper text to display for this field.	\N
20	placeholder	Placeholder	text	text	\N	meta.fields	\N	The placeholder value to display in a form input for this field.	\N
6	id	Page ID	int	text	\N	meta.pages	\N	The page's unique ID	\N
8	id	View ID	text	text	\N	meta.views	\N	The view ID	\N
12	id	Field ID	integer	text	\N	meta.fields	\N	The field's unique ID	\N
21	id	Form ID	integer	text	\N	meta.forms	\N	The form's unique ID.	\N
22	description	Description	text	text	\N	meta.forms	\N	A description of the form.	\N
23	use_param	Use Param	text	text	\N	meta.pages	\N	A query parameter to be used when matching the pages route	\N
24	query_id	Query ID	integer	text	\N	meta.pages	\N	A query ID to be used to drive the page build	\N
25	show_in_menu	Show in Menu	bool	select	{True,False}	meta.pages	\N	Whether to display this page in the page menu.	\N
26	weight	Weight	integer	text	\N	meta.fields	\N	Assign a "weight" property to determine the ordering of fields in views. The higher the weight, the earlier the field will be rendered. Best practice: use a scale of 100. Defaults to 1.	1
27	weight	Weight	integer	text	\N	meta.pages	\N	Assign a "weight" property to determine the ordering of page in the nav. The higher the weight, the earlier the page will be rendered. Best practice: use a scale of 100. Defaults to 1.	\N
2	name	Name	JSONB	text	\N	users	\N	Tip: this needs to be JSON. crazy, right? Try: {"first": "Pizza", "middle": "The", "last": "Hut"}}	John Doe
28	id	ID	integer	text	\N	users	\N	The user's unique ID	\N
29	id	ID	integer	text	\N	meta.queries	\N	The query's unique ID.	\N
30	gql	GraphQL	text	text_area	\N	meta.queries	\N	The query's graphql content	\N
31	description	Description	text	text	\N	meta.queries	\N	A description of what the query does	\N
\.


--
-- Data for Name: forms; Type: TABLE DATA; Schema: meta; Owner: postgres
--

COPY meta.forms (id, view_id, description, action, mutation) FROM stdin;
2	3	Create a new page.	insert	mutation insert_single_page($object: meta_pages_insert_input!) {   insert_meta_pages_one(object: $object) {     id     description     label     query_id     route     show_in_menu     slug     use_param     weight   } }
3	12	Create a field	insert	mutation insert_single_field($object: meta_fields_insert_input!) { insert_meta_fields_one(object: $object) { id } }
1	1	Create a new user.	insert	mutation insert_single_user($object: users_insert_input!) {   insert_users_one(object: $object) {     id   } }
4	16	Add Query	insert	mutation insert_single_user($object: users_insert_input!) { insert_users_one(object: $object) { id } }
\.


--
-- Data for Name: many_forms_to_many_fields; Type: TABLE DATA; Schema: meta; Owner: postgres
--

COPY meta.many_forms_to_many_fields (form_id, field_id, read_only, "row", weight) FROM stdin;
1	1	f	1	1
1	2	f	1	1
1	3	f	1	1
2	4	f	1	1
2	5	f	1	1
2	7	f	1	1
2	11	f	1	1
2	23	f	1	1
2	24	f	1	1
2	25	f	1	1
3	13	f	1	1
3	14	f	1	1
3	15	f	1	1
3	16	f	1	1
3	17	f	1	1
3	18	f	1	1
3	19	f	1	1
3	20	f	1	1
3	26	f	1	1
2	27	f	1	1
4	30	f	1	1
4	31	f	1	1
\.


--
-- Data for Name: many_tables_to_many_fields; Type: TABLE DATA; Schema: meta; Owner: postgres
--

COPY meta.many_tables_to_many_fields (table_id, field_id, read_only, weight) FROM stdin;
1	4	f	1
1	5	f	1
1	6	t	1
1	7	f	1
2	8	f	1
2	9	f	1
2	10	f	1
1	11	f	1
3	12	f	1
3	13	f	1
3	14	f	1
3	15	f	1
3	16	f	1
3	17	f	1
3	18	f	1
3	19	f	1
3	20	f	1
4	8	f	1
4	9	f	1
4	10	f	1
5	12	f	1
5	13	f	1
5	15	f	1
5	16	f	1
5	17	f	1
5	18	f	1
5	19	f	1
5	20	f	1
5	14	f	1
6	12	f	1
6	13	f	1
6	14	f	1
6	15	f	1
6	16	f	1
6	17	f	1
6	18	f	1
6	19	f	1
6	20	f	1
6	26	f	1
1	27	f	1
7	8	f	1
7	9	f	1
7	10	f	1
8	1	f	1
8	2	f	1
8	3	f	1
8	28	f	1
9	29	f	1
9	30	f	1
9	31	f	1
\.


--
-- Data for Name: menus; Type: TABLE DATA; Schema: meta; Owner: postgres
--

COPY meta.menus (id, buttons, label, description, view_id) FROM stdin;
1	[{"url": "/pages/builder", "label": "Add New Page", "variant": "secondary"}, {"url": "/", "label": "Do Nothing", "variant": "warning"}]	builder menu		11
\.


--
-- Data for Name: pages; Type: TABLE DATA; Schema: meta; Owner: postgres
--

COPY meta.pages (id, route, label, description, use_param, query_id, slug, show_in_menu, weight) FROM stdin;
5	/pages/	Page Details	This is a builder-focused meta page that displays the contents page in the app, given its slug.	slug	2	:slug	f	0
6	/tables/	Table Details	This is a builder-focused meta page the displays a Tables details.	id	6	:id	f	0
7	/forms/	Form Details	Details about the fields in a form	id	9	:id	f	0
3	/	Home	This is the home page.		\N	home	t	100
1	/	User Administration	Manage users on this page.		\N	user-admin	t	90
4	/	Pages	Configure this application.		\N	pages	t	80
8	/	Fields	 A listing of all fields in our metadata	false	\N	fields	t	70
528	/	Queries	These are all the queries used in the app by pages and views	false	\N	queries	t	60
529	/	Views	These are the views in this app.	false	\N	views	t	75
\.


--
-- Data for Name: queries; Type: TABLE DATA; Schema: meta; Owner: postgres
--

COPY meta.queries (id, gql, description) FROM stdin;
12	query AllUsers {   users {     email_address     id     name     status   } }	All users in the app
13	query AllQueries {   meta_queries {     id     gql     description   } }	All queries
6	query Pages { meta_pages(where: {route: {_eq: "/tables/"}}) { id label route slug description use_param query { id gql } views { id label tables { id query { gql } fields { field { id helper_text label name } } } forms { id fields { read_only row field { data_type helper_text id input_type label name options placeholder subfields table_name } } } } } }	Page meta data for /fields
4	query TableFields {   meta_tables_with_fields(where: {view_id: {_eq: $id}}) {     id     data_type     helper_text     input_type     label     options     placeholder     subfields     table_id     table_name     view_id   } }	Query fields related to a table based on view_id
2	query Pages {   meta_pages(where: {route: {_eq: "/pages/"}}) {     id     label     route     slug     description     use_param     query {       id       gql     }     views {       id       label       tables {         id         links         query {           gql         }         fields {           field {             id             helper_text             label             name           }         }       }       forms {         id         fields {           read_only           row           field {             data_type             helper_text             id             input_type             label             name             options             placeholder             subfields             table_name           }         }       }     }   } }	Query to build /pages components
3	query PagesViewsTables {   meta_views_with_pages_tables(where: {slug: {_eq: "$slug"}}) {     id     type     label   } }	Query tables related to a given page. Used to populate Page details meta builder page
7	query PagesViewsForms { meta_views_with_pages_forms(where: {slug: {_eq: "$slug"}}) { id type label } }	Query forms related to a given page. Used to populate Page details meta builder page
8	query FormFields {   meta_forms_with_fields(where: {view_id: {_eq: $id}}) {     id     data_type     helper_text     input_type     label     options     placeholder     subfields     form_id     table_name     view_id   } }	Query fields related to a form based on view_id
9	query Pages { meta_pages(where: {route: {_eq: "/forms/"}}) { id label route slug description use_param query { id gql } views { id label tables { id query { gql } fields { field { id helper_text label name } } } forms { id fields { read_only row field { data_type helper_text id input_type label name options placeholder subfields table_name } } } } } }	Query to view form details. 
10	query Fields {   meta_fields {     data_type     helper_text     id     input_type     label     name     options     placeholder     subfields     table_name     weight } }	Query all fields from metadata
1	query Pages {   meta_pages {     id     label     slug     route     description  weight } }	Query all app pages
11	query AllViews {   meta_views {     id     label     page_id     type     weight   } }	All views in the app
\.


--
-- Data for Name: tables; Type: TABLE DATA; Schema: meta; Owner: postgres
--

COPY meta.tables (id, view_id, links, query_id, description) FROM stdin;
1	5	{"id": "_link", "url": "/pages/$slug", "label": "Details", "use_param": "slug"}	1	Pages in this app
2	6	{"id": "_link", "url": "/tables/$id", "label": "Details", "use_param": "id"}	3	Tables in this page
4	8	{"id": "_link", "url": "/forms/$id", "label": "Details", "use_param": "id"}	7	Forms in this page.
3	7	\N	4	Shows fields in this table
5	9	\N	8	Fields in this form
6	10	\N	10	All fields
7	13	\N	11	Views in this App
8	14	\N	12	All Users
9	15	\N	13	All queries
\.


--
-- Data for Name: views; Type: TABLE DATA; Schema: meta; Owner: postgres
--

COPY meta.views (id, page_id, label, type, weight) FROM stdin;
5	4	Pages in this App	table	0
6	5	Tables in this Page	table	0
8	5	Forms in this Page	table	0
7	6	Fields in this table	table	0
9	7	Form Details	table	0
10	8	Fields	table	0
11	4	Create a Page	menu	100
12	8	Create Field	form	90
13	529	Views	table	70
3	4	Create Page	form	0
14	1	User Table	table	10
1	1	Create User	form	100
15	528	Queries	table	10
16	528	Create Query	form	90
\.


--
-- Data for Name: locations; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.locations (id, landmark, council_district, modified_date, location_name, knack_id) FROM stdin;
1	Walmart	{9,3}	1971-07-13 00:00:00+00	CESAR CHAVEZ / I35	abc123
\.


--
-- Data for Name: tmc_activities; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.tmc_activities (id, tmc_activity, tmc_activity_datetime, tmc_issue_id) FROM stdin;
1	do thing	2020-07-20 00:00:00+00	1
\.


--
-- Data for Name: tmc_issues; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.tmc_issues (id, issue_description, location_id) FROM stdin;
1	did something cool	1
2	did something really cool	1
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users (email_address, name, id, status) FROM stdin;
john.clary@austintexas.gov	"{\\"first\\": \\"John\\", \\"last\\": \\"Clary\\"}"	1	active
fake@fake.com	"{\\"first\\": \\"John\\", \\"last\\": \\"Clary\\"}"	4	'inactive'
pizza@pizza/com	"asdfasdf"	5	active
asdfasdfa	"asdfasdf"	6	active
\.


--
-- Name: remote_schemas_id_seq; Type: SEQUENCE SET; Schema: hdb_catalog; Owner: postgres
--

SELECT pg_catalog.setval('hdb_catalog.remote_schemas_id_seq', 1, false);


--
-- Name: fields_id_seq; Type: SEQUENCE SET; Schema: meta; Owner: postgres
--

SELECT pg_catalog.setval('meta.fields_id_seq', 31, true);


--
-- Name: forms_id_seq; Type: SEQUENCE SET; Schema: meta; Owner: postgres
--

SELECT pg_catalog.setval('meta.forms_id_seq', 4, true);


--
-- Name: menus_id_seq; Type: SEQUENCE SET; Schema: meta; Owner: postgres
--

SELECT pg_catalog.setval('meta.menus_id_seq', 1, true);


--
-- Name: pages_id_seq; Type: SEQUENCE SET; Schema: meta; Owner: postgres
--

SELECT pg_catalog.setval('meta.pages_id_seq', 529, true);


--
-- Name: queries_id_seq; Type: SEQUENCE SET; Schema: meta; Owner: postgres
--

SELECT pg_catalog.setval('meta.queries_id_seq', 13, true);


--
-- Name: tables_id_seq; Type: SEQUENCE SET; Schema: meta; Owner: postgres
--

SELECT pg_catalog.setval('meta.tables_id_seq', 9, true);


--
-- Name: views_id_seq; Type: SEQUENCE SET; Schema: meta; Owner: postgres
--

SELECT pg_catalog.setval('meta.views_id_seq', 16, true);


--
-- Name: locations_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.locations_id_seq', 4, true);


--
-- Name: tmc_activities_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.tmc_activities_id_seq', 1, true);


--
-- Name: tmc_issues_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.tmc_issues_id_seq', 2, true);


--
-- Name: users_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.users_id_seq', 6, true);


--
-- Name: event_invocation_logs event_invocation_logs_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.event_invocation_logs
    ADD CONSTRAINT event_invocation_logs_pkey PRIMARY KEY (id);


--
-- Name: event_log event_log_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.event_log
    ADD CONSTRAINT event_log_pkey PRIMARY KEY (id);


--
-- Name: event_triggers event_triggers_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.event_triggers
    ADD CONSTRAINT event_triggers_pkey PRIMARY KEY (name);


--
-- Name: hdb_action_log hdb_action_log_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_action_log
    ADD CONSTRAINT hdb_action_log_pkey PRIMARY KEY (id);


--
-- Name: hdb_action_permission hdb_action_permission_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_action_permission
    ADD CONSTRAINT hdb_action_permission_pkey PRIMARY KEY (action_name, role_name);


--
-- Name: hdb_action hdb_action_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_action
    ADD CONSTRAINT hdb_action_pkey PRIMARY KEY (action_name);


--
-- Name: hdb_allowlist hdb_allowlist_collection_name_key; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_allowlist
    ADD CONSTRAINT hdb_allowlist_collection_name_key UNIQUE (collection_name);


--
-- Name: hdb_computed_field hdb_computed_field_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_computed_field
    ADD CONSTRAINT hdb_computed_field_pkey PRIMARY KEY (table_schema, table_name, computed_field_name);


--
-- Name: hdb_function hdb_function_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_function
    ADD CONSTRAINT hdb_function_pkey PRIMARY KEY (function_schema, function_name);


--
-- Name: hdb_permission hdb_permission_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_permission
    ADD CONSTRAINT hdb_permission_pkey PRIMARY KEY (table_schema, table_name, role_name, perm_type);


--
-- Name: hdb_query_collection hdb_query_collection_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_query_collection
    ADD CONSTRAINT hdb_query_collection_pkey PRIMARY KEY (collection_name);


--
-- Name: hdb_relationship hdb_relationship_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_relationship
    ADD CONSTRAINT hdb_relationship_pkey PRIMARY KEY (table_schema, table_name, rel_name);


--
-- Name: hdb_table hdb_table_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_table
    ADD CONSTRAINT hdb_table_pkey PRIMARY KEY (table_schema, table_name);


--
-- Name: hdb_version hdb_version_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_version
    ADD CONSTRAINT hdb_version_pkey PRIMARY KEY (hasura_uuid);


--
-- Name: remote_schemas remote_schemas_name_key; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.remote_schemas
    ADD CONSTRAINT remote_schemas_name_key UNIQUE (name);


--
-- Name: remote_schemas remote_schemas_pkey; Type: CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.remote_schemas
    ADD CONSTRAINT remote_schemas_pkey PRIMARY KEY (id);


--
-- Name: fields fields_pkey; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.fields
    ADD CONSTRAINT fields_pkey PRIMARY KEY (id);


--
-- Name: forms forms_pkey; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.forms
    ADD CONSTRAINT forms_pkey PRIMARY KEY (id);


--
-- Name: menus menus_pkey; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.menus
    ADD CONSTRAINT menus_pkey PRIMARY KEY (id);


--
-- Name: pages pages_pkey; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.pages
    ADD CONSTRAINT pages_pkey PRIMARY KEY (id);


--
-- Name: pages pages_route_slug_key; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.pages
    ADD CONSTRAINT pages_route_slug_key UNIQUE (route, slug);


--
-- Name: many_forms_to_many_fields pk_forms_fields; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.many_forms_to_many_fields
    ADD CONSTRAINT pk_forms_fields PRIMARY KEY (form_id, field_id);


--
-- Name: many_tables_to_many_fields pk_tables_fields; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.many_tables_to_many_fields
    ADD CONSTRAINT pk_tables_fields PRIMARY KEY (table_id, field_id);


--
-- Name: queries queries_pkey; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.queries
    ADD CONSTRAINT queries_pkey PRIMARY KEY (id);


--
-- Name: tables tables_pkey; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.tables
    ADD CONSTRAINT tables_pkey PRIMARY KEY (id);


--
-- Name: views views_label_key; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.views
    ADD CONSTRAINT views_label_key UNIQUE (label);


--
-- Name: views views_pkey; Type: CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.views
    ADD CONSTRAINT views_pkey PRIMARY KEY (id);


--
-- Name: locations locations_knack_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.locations
    ADD CONSTRAINT locations_knack_id_key UNIQUE (knack_id);


--
-- Name: locations locations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.locations
    ADD CONSTRAINT locations_pkey PRIMARY KEY (id);


--
-- Name: tmc_activities tmc_activities_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tmc_activities
    ADD CONSTRAINT tmc_activities_pkey PRIMARY KEY (id);


--
-- Name: tmc_issues tmc_issues_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tmc_issues
    ADD CONSTRAINT tmc_issues_pkey PRIMARY KEY (id);


--
-- Name: users users_email_address_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_email_address_key UNIQUE (email_address);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: event_invocation_logs_event_id_idx; Type: INDEX; Schema: hdb_catalog; Owner: postgres
--

CREATE INDEX event_invocation_logs_event_id_idx ON hdb_catalog.event_invocation_logs USING btree (event_id);


--
-- Name: event_log_created_at_idx; Type: INDEX; Schema: hdb_catalog; Owner: postgres
--

CREATE INDEX event_log_created_at_idx ON hdb_catalog.event_log USING btree (created_at);


--
-- Name: event_log_delivered_idx; Type: INDEX; Schema: hdb_catalog; Owner: postgres
--

CREATE INDEX event_log_delivered_idx ON hdb_catalog.event_log USING btree (delivered);


--
-- Name: event_log_locked_idx; Type: INDEX; Schema: hdb_catalog; Owner: postgres
--

CREATE INDEX event_log_locked_idx ON hdb_catalog.event_log USING btree (locked);


--
-- Name: event_log_trigger_name_idx; Type: INDEX; Schema: hdb_catalog; Owner: postgres
--

CREATE INDEX event_log_trigger_name_idx ON hdb_catalog.event_log USING btree (trigger_name);


--
-- Name: hdb_schema_update_event_one_row; Type: INDEX; Schema: hdb_catalog; Owner: postgres
--

CREATE UNIQUE INDEX hdb_schema_update_event_one_row ON hdb_catalog.hdb_schema_update_event USING btree (((occurred_at IS NOT NULL)));


--
-- Name: hdb_version_one_row; Type: INDEX; Schema: hdb_catalog; Owner: postgres
--

CREATE UNIQUE INDEX hdb_version_one_row ON hdb_catalog.hdb_version USING btree (((version IS NOT NULL)));


--
-- Name: hdb_schema_update_event hdb_schema_update_event_notifier; Type: TRIGGER; Schema: hdb_catalog; Owner: postgres
--

CREATE TRIGGER hdb_schema_update_event_notifier AFTER INSERT OR UPDATE ON hdb_catalog.hdb_schema_update_event FOR EACH ROW EXECUTE FUNCTION hdb_catalog.hdb_schema_update_event_notifier();


--
-- Name: event_invocation_logs event_invocation_logs_event_id_fkey; Type: FK CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.event_invocation_logs
    ADD CONSTRAINT event_invocation_logs_event_id_fkey FOREIGN KEY (event_id) REFERENCES hdb_catalog.event_log(id);


--
-- Name: event_triggers event_triggers_schema_name_table_name_fkey; Type: FK CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.event_triggers
    ADD CONSTRAINT event_triggers_schema_name_table_name_fkey FOREIGN KEY (schema_name, table_name) REFERENCES hdb_catalog.hdb_table(table_schema, table_name) ON UPDATE CASCADE;


--
-- Name: hdb_action_permission hdb_action_permission_action_name_fkey; Type: FK CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_action_permission
    ADD CONSTRAINT hdb_action_permission_action_name_fkey FOREIGN KEY (action_name) REFERENCES hdb_catalog.hdb_action(action_name) ON UPDATE CASCADE;


--
-- Name: hdb_allowlist hdb_allowlist_collection_name_fkey; Type: FK CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_allowlist
    ADD CONSTRAINT hdb_allowlist_collection_name_fkey FOREIGN KEY (collection_name) REFERENCES hdb_catalog.hdb_query_collection(collection_name);


--
-- Name: hdb_computed_field hdb_computed_field_table_schema_table_name_fkey; Type: FK CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_computed_field
    ADD CONSTRAINT hdb_computed_field_table_schema_table_name_fkey FOREIGN KEY (table_schema, table_name) REFERENCES hdb_catalog.hdb_table(table_schema, table_name) ON UPDATE CASCADE;


--
-- Name: hdb_permission hdb_permission_table_schema_table_name_fkey; Type: FK CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_permission
    ADD CONSTRAINT hdb_permission_table_schema_table_name_fkey FOREIGN KEY (table_schema, table_name) REFERENCES hdb_catalog.hdb_table(table_schema, table_name) ON UPDATE CASCADE;


--
-- Name: hdb_relationship hdb_relationship_table_schema_table_name_fkey; Type: FK CONSTRAINT; Schema: hdb_catalog; Owner: postgres
--

ALTER TABLE ONLY hdb_catalog.hdb_relationship
    ADD CONSTRAINT hdb_relationship_table_schema_table_name_fkey FOREIGN KEY (table_schema, table_name) REFERENCES hdb_catalog.hdb_table(table_schema, table_name) ON UPDATE CASCADE;


--
-- Name: views fk_pages; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.views
    ADD CONSTRAINT fk_pages FOREIGN KEY (page_id) REFERENCES meta.pages(id);


--
-- Name: forms forms_view_id_fkey; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.forms
    ADD CONSTRAINT forms_view_id_fkey FOREIGN KEY (view_id) REFERENCES meta.views(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: many_forms_to_many_fields many_forms_to_many_fields_field_id_fkey; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.many_forms_to_many_fields
    ADD CONSTRAINT many_forms_to_many_fields_field_id_fkey FOREIGN KEY (field_id) REFERENCES meta.fields(id);


--
-- Name: many_forms_to_many_fields many_forms_to_many_fields_form_id_fkey; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.many_forms_to_many_fields
    ADD CONSTRAINT many_forms_to_many_fields_form_id_fkey FOREIGN KEY (form_id) REFERENCES meta.forms(id);


--
-- Name: many_tables_to_many_fields many_tables_to_many_fieds_field_id_fkey; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.many_tables_to_many_fields
    ADD CONSTRAINT many_tables_to_many_fieds_field_id_fkey FOREIGN KEY (field_id) REFERENCES meta.fields(id);


--
-- Name: many_tables_to_many_fields many_tables_to_many_fieds_table_id_fkey; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.many_tables_to_many_fields
    ADD CONSTRAINT many_tables_to_many_fieds_table_id_fkey FOREIGN KEY (table_id) REFERENCES meta.tables(id);


--
-- Name: menus menus_view_id_fkey; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.menus
    ADD CONSTRAINT menus_view_id_fkey FOREIGN KEY (view_id) REFERENCES meta.views(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: pages pages_query_id_fkey; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.pages
    ADD CONSTRAINT pages_query_id_fkey FOREIGN KEY (query_id) REFERENCES meta.queries(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: tables tables_query_id_fkey; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.tables
    ADD CONSTRAINT tables_query_id_fkey FOREIGN KEY (query_id) REFERENCES meta.queries(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: tables tables_view_id_fkey; Type: FK CONSTRAINT; Schema: meta; Owner: postgres
--

ALTER TABLE ONLY meta.tables
    ADD CONSTRAINT tables_view_id_fkey FOREIGN KEY (view_id) REFERENCES meta.views(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: tmc_issues fk_location; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tmc_issues
    ADD CONSTRAINT fk_location FOREIGN KEY (location_id) REFERENCES public.locations(id);


--
-- Name: tmc_activities fk_tmc_issue; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tmc_activities
    ADD CONSTRAINT fk_tmc_issue FOREIGN KEY (tmc_issue_id) REFERENCES public.tmc_issues(id);


--
-- PostgreSQL database dump complete
--

